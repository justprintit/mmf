#!/bin/sh

set -eu

F="${0%.sh}_sh.go"
trap "rm -f '$F~'" EXIT
exec > "$F~"

cat <<EOT
package library

//go:generate $0

import (
	"context"
)

// Code generated by $0 DO NOT EDIT

// pulls all data from the server
func (c *Client) RefreshLibraries(ctx context.Context) error {
	// load persistent data
	if err := c.Reload(); err != nil {
		return err
	}
EOT

for x in "Shared with me" Purchases Pledges Tribes; do

	msg=$(echo "$x" | tr A-Z a-z)
	key="${x%% *}"
	cat <<EOT

	// $msg
	c.Add(func(c *Client, ctx context.Context) error {
		return c.Refresh${key}Library(ctx)
	})
EOT
done
cat <<EOT
	return nil
}
EOT

for x in Shared Purchases Pledges Tribes:i; do
	n=${x%%:*}
	if [ "$n" != "$x" ]; then
		pages=Pages
	else
		pages=PagesN
	fi

cat <<EOT

func (c *Client) Refresh${n}Library(ctx context.Context) error {
	var p *Pagination

	page := 1
	ok := true

	for ok {
		// get json items
		d, err := c.Get${n}LibraryPage(ctx, page)
		if err != nil {
			return err
		}

		if p == nil {
			// first page
			p = c.$pages(len(d.Items), d.Count)
		}

		// process in parallel
		offset := p.Size * (page - 1)
		c.Spawn(func(c *Client, ctx context.Context) error {
			return c.refresh${n}Library(ctx, offset, d.Items...)
		})

		// next page
		page, _, ok = p.Next(page)
	}

	return nil
}
EOT
done

if ! diff -u "$F" "$F~" >&2; then
	mv "$F~" "$F"
fi
