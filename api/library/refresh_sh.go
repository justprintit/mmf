package library

//go:generate ./refresh.sh

import (
	"context"
)

// Code generated by ./refresh.sh DO NOT EDIT

// pulls all data from the server
func (c *Client) RefreshLibraries(ctx context.Context) error {
	// load persistent data
	if err := c.Reload(); err != nil {
		return err
	}

	// shared with me
	c.Add(func(c *Client, ctx context.Context) error {
		return c.RefreshSharedLibrary(ctx)
	})

	// purchases
	c.Add(func(c *Client, ctx context.Context) error {
		return c.RefreshPurchasesLibrary(ctx)
	})

	// pledges
	c.Add(func(c *Client, ctx context.Context) error {
		return c.RefreshPledgesLibrary(ctx)
	})

	// tribes
	c.Add(func(c *Client, ctx context.Context) error {
		return c.RefreshTribesLibrary(ctx)
	})
	return nil
}

func (c *Client) RefreshSharedLibrary(ctx context.Context) error {
	var p *Pagination

	page := 1
	ok := true

	for ok {
		// get json items
		d, err := c.GetSharedLibraryPage(ctx, page)
		if err != nil {
			return err
		}

		if p == nil {
			// first page
			p = c.PagesN(len(d.Items), d.Count)
		}

		// process in parallel
		offset := p.Size * (page - 1)
		c.Spawn(func(c *Client, ctx context.Context) error {
			return c.refreshSharedLibrary(ctx, offset, d.Items...)
		})

		// next page
		page, _, ok = p.Next(page)
	}

	return nil
}

func (c *Client) RefreshPurchasesLibrary(ctx context.Context) error {
	var p *Pagination

	page := 1
	ok := true

	for ok {
		// get json items
		d, err := c.GetPurchasesLibraryPage(ctx, page)
		if err != nil {
			return err
		}

		if p == nil {
			// first page
			p = c.PagesN(len(d.Items), d.Count)
		}

		// process in parallel
		offset := p.Size * (page - 1)
		c.Spawn(func(c *Client, ctx context.Context) error {
			return c.refreshPurchasesLibrary(ctx, offset, d.Items...)
		})

		// next page
		page, _, ok = p.Next(page)
	}

	return nil
}

func (c *Client) RefreshPledgesLibrary(ctx context.Context) error {
	var p *Pagination

	page := 1
	ok := true

	for ok {
		// get json items
		d, err := c.GetPledgesLibraryPage(ctx, page)
		if err != nil {
			return err
		}

		if p == nil {
			// first page
			p = c.PagesN(len(d.Items), d.Count)
		}

		// process in parallel
		offset := p.Size * (page - 1)
		c.Spawn(func(c *Client, ctx context.Context) error {
			return c.refreshPledgesLibrary(ctx, offset, d.Items...)
		})

		// next page
		page, _, ok = p.Next(page)
	}

	return nil
}

func (c *Client) RefreshTribesLibrary(ctx context.Context) error {
	var p *Pagination

	page := 1
	ok := true

	for ok {
		// get json items
		d, err := c.GetTribesLibraryPage(ctx, page)
		if err != nil {
			return err
		}

		if p == nil {
			// first page
			p = c.Pages(len(d.Items), d.Count)
		}

		// process in parallel
		offset := p.Size * (page - 1)
		c.Spawn(func(c *Client, ctx context.Context) error {
			return c.refreshTribesLibrary(ctx, offset, d.Items...)
		})

		// next page
		page, _, ok = p.Next(page)
	}

	return nil
}
