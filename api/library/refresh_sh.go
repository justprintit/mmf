package library

//go:generate ./refresh.sh

import (
	"context"
	"os"

	"github.com/go-resty/resty/v2"

	"github.com/justprintit/mmf/api/client"
	"github.com/justprintit/mmf/api/library/json"
)

// Code generated by ./refresh.sh DO NOT EDIT

// Shared
var SharedLibraryRequest = client.RequestOptions{
	Accept:  "application/json",
	Referer: "/library/?v=shared",
	Path:    "/data-library/shared",
	Method:  "GET",
	Result:  json.Users{},
}

func SharedLibraryResult(resp *resty.Response) *json.Users {
	if out := resp.Result(); out != nil {
		return out.(*json.Users)
	}
	return nil
}

// Purchases
var PurchasesLibraryRequest = client.RequestOptions{
	Accept:  "application/json",
	Referer: "/library/?v=purchases",
	Path:    "/data-library/purchases",
	Method:  "GET",
	Result:  json.Objects{},
}

func PurchasesLibraryResult(resp *resty.Response) *json.Objects {
	if out := resp.Result(); out != nil {
		return out.(*json.Objects)
	}
	return nil
}

// Pledges
var PledgesLibraryRequest = client.RequestOptions{
	Accept:  "application/json",
	Referer: "/library/?v=campaigns",
	Path:    "/data-library/campaigns",
	Method:  "GET",
	Result:  json.Objects{},
}

func PledgesLibraryResult(resp *resty.Response) *json.Objects {
	if out := resp.Result(); out != nil {
		return out.(*json.Objects)
	}
	return nil
}

// Tribes
var TribesLibraryRequest = client.RequestOptions{
	Accept:  "application/json",
	Referer: "/library/?v=my-tribes",
	Path:    "/data-library/tribes",
	Method:  "GET",
	Result:  json.Tribes{},
}

func TribesLibraryResult(resp *resty.Response) *json.Tribes {
	if out := resp.Result(); out != nil {
		return out.(*json.Tribes)
	}
	return nil
}

// pulls all data from the server
func (c *Client) RefreshLibraries(ctx context.Context) error {
	// load persistent data
	if err := c.Reload(); err != nil {
		return err
	}

	// schedule downloads to refresh libraries
	c.SchedulePageRequest(SharedLibraryRequest, 0, refreshSharedLibraryCallback)
	c.SchedulePageRequest(PurchasesLibraryRequest, 0, refreshPurchasesLibraryCallback)
	c.SchedulePageRequest(PledgesLibraryRequest, 0, refreshPledgesLibraryCallback)
	c.SchedulePageRequest(TribesLibraryRequest, 0, refreshTribesLibraryCallback)

	return nil
}

// get all JSON data of Shared library
func (c *Client) GetSharedLibrary(ctx context.Context) (*json.Users, error) {
	d, err := c.GetSharedLibraryPage(ctx, 0)
	if err == nil {
		// pagination
		p := c.PagesN(len(d.Items), d.Count)

		// download further pages if needed
		page, _, ok := p.Next(1)
		for ok {
			var d2 *json.Users

			d2, err = c.GetSharedLibraryPage(ctx, page)
			if err != nil {
				break
			}

			d.Items = append(d.Items, d2.Items...)
		}
	}
	return d, err
}

// get requested page of JSON data of Shared library
func (c *Client) GetSharedLibraryPage(ctx context.Context, page int) (*json.Users, error) {
	resp, err := c.GetPage(ctx, SharedLibraryRequest, page)
	if err != nil {
		os.Stdout.Write(resp.Body())
		return nil, err
	}

	out := SharedLibraryResult(resp)
	return out, nil
}

// pull first page of Shared library
func (c *Client) RefreshSharedLibrary(ctx context.Context) error {
	c.SchedulePageRequest(SharedLibraryRequest, 0, refreshSharedLibraryCallback)
	return nil
}

// handle first page of Shared library
func refreshSharedLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := SharedLibraryResult(resp)

	// pagination
	p := c.PagesN(len(d.Items), d.Count)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(SharedLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := SharedLibraryResult(resp)
			return c.refreshSharedLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshSharedLibrary(ctx, 0, d.Items...)
}

// get all JSON data of Purchases library
func (c *Client) GetPurchasesLibrary(ctx context.Context) (*json.Objects, error) {
	d, err := c.GetPurchasesLibraryPage(ctx, 0)
	if err == nil {
		// pagination
		p := c.PagesN(len(d.Items), d.Count)

		// download further pages if needed
		page, _, ok := p.Next(1)
		for ok {
			var d2 *json.Objects

			d2, err = c.GetPurchasesLibraryPage(ctx, page)
			if err != nil {
				break
			}

			d.Items = append(d.Items, d2.Items...)
		}
	}
	return d, err
}

// get requested page of JSON data of Purchases library
func (c *Client) GetPurchasesLibraryPage(ctx context.Context, page int) (*json.Objects, error) {
	resp, err := c.GetPage(ctx, PurchasesLibraryRequest, page)
	if err != nil {
		os.Stdout.Write(resp.Body())
		return nil, err
	}

	out := PurchasesLibraryResult(resp)
	return out, nil
}

// pull first page of Purchases library
func (c *Client) RefreshPurchasesLibrary(ctx context.Context) error {
	c.SchedulePageRequest(PurchasesLibraryRequest, 0, refreshPurchasesLibraryCallback)
	return nil
}

// handle first page of Purchases library
func refreshPurchasesLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := PurchasesLibraryResult(resp)

	// pagination
	p := c.PagesN(len(d.Items), d.Count)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(PurchasesLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := PurchasesLibraryResult(resp)
			return c.refreshPurchasesLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshPurchasesLibrary(ctx, 0, d.Items...)
}

// get all JSON data of Pledges library
func (c *Client) GetPledgesLibrary(ctx context.Context) (*json.Objects, error) {
	d, err := c.GetPledgesLibraryPage(ctx, 0)
	if err == nil {
		// pagination
		p := c.PagesN(len(d.Items), d.Count)

		// download further pages if needed
		page, _, ok := p.Next(1)
		for ok {
			var d2 *json.Objects

			d2, err = c.GetPledgesLibraryPage(ctx, page)
			if err != nil {
				break
			}

			d.Items = append(d.Items, d2.Items...)
		}
	}
	return d, err
}

// get requested page of JSON data of Pledges library
func (c *Client) GetPledgesLibraryPage(ctx context.Context, page int) (*json.Objects, error) {
	resp, err := c.GetPage(ctx, PledgesLibraryRequest, page)
	if err != nil {
		os.Stdout.Write(resp.Body())
		return nil, err
	}

	out := PledgesLibraryResult(resp)
	return out, nil
}

// pull first page of Pledges library
func (c *Client) RefreshPledgesLibrary(ctx context.Context) error {
	c.SchedulePageRequest(PledgesLibraryRequest, 0, refreshPledgesLibraryCallback)
	return nil
}

// handle first page of Pledges library
func refreshPledgesLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := PledgesLibraryResult(resp)

	// pagination
	p := c.PagesN(len(d.Items), d.Count)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(PledgesLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := PledgesLibraryResult(resp)
			return c.refreshPledgesLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshPledgesLibrary(ctx, 0, d.Items...)
}

// get all JSON data of Tribes library
func (c *Client) GetTribesLibrary(ctx context.Context) (*json.Tribes, error) {
	d, err := c.GetTribesLibraryPage(ctx, 0)
	if err == nil {
		// pagination
		p := c.Pages(len(d.Items), d.Count)

		// download further pages if needed
		page, _, ok := p.Next(1)
		for ok {
			var d2 *json.Tribes

			d2, err = c.GetTribesLibraryPage(ctx, page)
			if err != nil {
				break
			}

			d.Items = append(d.Items, d2.Items...)
		}
	}
	return d, err
}

// get requested page of JSON data of Tribes library
func (c *Client) GetTribesLibraryPage(ctx context.Context, page int) (*json.Tribes, error) {
	resp, err := c.GetPage(ctx, TribesLibraryRequest, page)
	if err != nil {
		os.Stdout.Write(resp.Body())
		return nil, err
	}

	out := TribesLibraryResult(resp)
	return out, nil
}

// pull first page of Tribes library
func (c *Client) RefreshTribesLibrary(ctx context.Context) error {
	c.SchedulePageRequest(TribesLibraryRequest, 0, refreshTribesLibraryCallback)
	return nil
}

// handle first page of Tribes library
func refreshTribesLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := TribesLibraryResult(resp)

	// pagination
	p := c.Pages(len(d.Items), d.Count)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(TribesLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := TribesLibraryResult(resp)
			return c.refreshTribesLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshTribesLibrary(ctx, 0, d.Items...)
}
