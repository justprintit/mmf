package library

//go:generate ./refresh.sh

import (
	"context"
	"time"

	"github.com/go-resty/resty/v2"

	"github.com/justprintit/mmf/api/library/json"
	"github.com/justprintit/mmf/api/library/types"
)

// Code generated by ./refresh.sh DO NOT EDIT

// pulls all data from the server
func (c *Client) RefreshLibraries(ctx context.Context) error {
	// load persistent data
	if err := c.Reload(); err != nil {
		return err
	}

	// schedule downloads to refresh libraries
	c.SchedulePageRequest(json.SharedLibraryRequest, 0, refreshSharedLibraryCallback)
	c.SchedulePageRequest(json.PurchasesLibraryRequest, 0, refreshPurchasesLibraryCallback)
	c.SchedulePageRequest(json.PledgesLibraryRequest, 0, refreshPledgesLibraryCallback)
	c.SchedulePageRequest(json.TribesLibraryRequest, 0, refreshTribesLibraryCallback)

	return nil
}

// pull first page of Shared library
func (c *Client) RefreshSharedLibrary(ctx context.Context) error {
	c.SchedulePageRequest(json.SharedLibraryRequest, 0, refreshSharedLibraryCallback)
	return nil
}

// handle first page of Shared library
func refreshSharedLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := json.SharedLibraryResult(resp)

	// pagination
	p := json.UsersPages(d)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(json.SharedLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := json.SharedLibraryResult(resp)
			return c.refreshSharedLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshSharedLibrary(ctx, 0, d.Items...)
}

// pull first page of Purchases library
func (c *Client) RefreshPurchasesLibrary(ctx context.Context) error {
	c.SchedulePageRequest(json.PurchasesLibraryRequest, 0, refreshPurchasesLibraryCallback)
	return nil
}

// handle first page of Purchases library
func refreshPurchasesLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := json.PurchasesLibraryResult(resp)

	// pagination
	p := json.ObjectsPages(d)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(json.PurchasesLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := json.PurchasesLibraryResult(resp)
			return c.refreshPurchasesLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshPurchasesLibrary(ctx, 0, d.Items...)
}

// pull first page of Pledges library
func (c *Client) RefreshPledgesLibrary(ctx context.Context) error {
	c.SchedulePageRequest(json.PledgesLibraryRequest, 0, refreshPledgesLibraryCallback)
	return nil
}

// handle first page of Pledges library
func refreshPledgesLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := json.PledgesLibraryResult(resp)

	// pagination
	p := json.ObjectsPages(d)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(json.PledgesLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := json.PledgesLibraryResult(resp)
			return c.refreshPledgesLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshPledgesLibrary(ctx, 0, d.Items...)
}

// pull first page of Tribes library
func (c *Client) RefreshTribesLibrary(ctx context.Context) error {
	c.SchedulePageRequest(json.TribesLibraryRequest, 0, refreshTribesLibraryCallback)
	return nil
}

// handle first page of Tribes library
func refreshTribesLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	d := json.TribesLibraryResult(resp)

	// pagination
	p := json.TribesPages(d)

	// schedule further pages if needed
	page, offset, ok := p.Next(1)
	for ok {
		off := offset
		c.SchedulePageRequest(json.TribesLibraryRequest, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
			d := json.TribesLibraryResult(resp)
			return c.refreshTribesLibrary(ctx, off, d.Items...)
		})

		// next page
		page, offset, ok = p.Next(page)
	}

	// and process first page
	return c.refreshTribesLibrary(ctx, 0, d.Items...)
}

// handle first page of UserSharedLibrary
func refreshUserSharedLibraryCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	if d := json.UserSharedLibraryResult(resp); d != nil {
		req := resp.RawResponse.Request

		// process the first page
		if err := c.refreshUserSharedLibraryFromRequest(ctx, req, d); err != nil {
			return err
		}

		// and schedule further pages if needed
		p := json.UserSharedLibraryPages(d)
		if page, _, ok := p.Next(1); ok {
			opt := json.NewUserSharedLibraryFromRequest(req)

			for ok {
				c.SchedulePageRequest(opt, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
					d := json.UserSharedLibraryResult(resp)
					req := resp.RawResponse.Request

					return c.refreshUserSharedLibraryFromRequest(ctx, req, d)
				})

				// next page
				page, _, ok = p.Next(page)
			}
		}
	}
	return nil
}

// handle first page of UserSharedGroup
func refreshUserSharedGroupCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	if d := json.UserSharedGroupResult(resp); d != nil {
		req := resp.RawResponse.Request

		// process the first page
		if err := c.refreshUserSharedGroupFromRequest(ctx, req, d); err != nil {
			return err
		}

		// and schedule further pages if needed
		p := json.ObjectsPages(d)
		if page, _, ok := p.Next(1); ok {
			opt := json.NewUserSharedGroupFromRequest(req)

			for ok {
				c.SchedulePageRequest(opt, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
					d := json.UserSharedGroupResult(resp)
					req := resp.RawResponse.Request

					return c.refreshUserSharedGroupFromRequest(ctx, req, d)
				})

				// next page
				page, _, ok = p.Next(page)
			}
		}
	}
	return nil
}

// handle first page of TribeSharedGroup
func refreshTribeSharedGroupCallback(c *Client, ctx context.Context, resp *resty.Response) error {
	if d := json.TribeSharedGroupResult(resp); d != nil {
		req := resp.RawResponse.Request

		// process the first page
		if err := c.refreshTribeSharedGroupFromRequest(ctx, req, d); err != nil {
			return err
		}

		// and schedule further pages if needed
		p := json.ObjectsPages(d)
		if page, _, ok := p.Next(1); ok {
			opt := json.NewTribeSharedGroupFromRequest(req)

			for ok {
				c.SchedulePageRequest(opt, page, func(c *Client, ctx context.Context, resp *resty.Response) error {
					d := json.TribeSharedGroupResult(resp)
					req := resp.RawResponse.Request

					return c.refreshTribeSharedGroupFromRequest(ctx, req, d)
				})

				// next page
				page, _, ok = p.Next(page)
			}
		}
	}
	return nil
}

func (c *Client) scheduleUserSharedLibrary(ctx context.Context, u *types.User) error {
	select {
	case <-ctx.Done():
		// cancelled
		return ctx.Err()
	default:
		t := time.Now()
		if t.After(u.NextUserSharedLibraryUpdate) {
			u.NextUserSharedLibraryUpdate = t.Add(NextUserSharedLibraryUpdate)

			req := json.NewUserSharedLibraryRequest(u)
			c.Download(req, refreshUserSharedLibraryCallback)
		}
		return nil
	}
}

func (c *Client) scheduleUserSharedGroup(ctx context.Context, u *types.User) error {
	select {
	case <-ctx.Done():
		// cancelled
		return ctx.Err()
	default:
		t := time.Now()
		for _, g := range u.GroupsAll() {
			if t.After(g.NextGroupObjectsUpdate) {
				g.NextGroupObjectsUpdate = t.Add(NextGroupObjectsUpdate)

				req := json.NewUserSharedGroupRequest(g)
				c.Download(req, refreshUserSharedGroupCallback)
			}
		}
		return nil
	}
}

func (c *Client) scheduleTribeSharedGroup(ctx context.Context, u *types.Tribe) error {
	select {
	case <-ctx.Done():
		// cancelled
		return ctx.Err()
	default:
		t := time.Now()
		for _, g := range u.GroupsAll() {
			if t.After(g.NextGroupObjectsUpdate) {
				g.NextGroupObjectsUpdate = t.Add(NextGroupObjectsUpdate)

				req := json.NewTribeSharedGroupRequest(g)
				c.Download(req, refreshTribeSharedGroupCallback)
			}
		}
		return nil
	}
}
